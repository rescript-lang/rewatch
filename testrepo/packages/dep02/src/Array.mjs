// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";

function includes(prim0, prim1) {
  return prim0.includes(prim1);
}

function head(t) {
  return Belt_Array.get(t, 0);
}

function take(t, n) {
  return Belt_Array.slice(t, 0, n);
}

function last(t) {
  return Belt_Array.get(t, t.length - 1 | 0);
}

function isEmpty(t) {
  return t.length === 0;
}

function isNotEmpty(t) {
  return t.length !== 0;
}

function append(t, v) {
  return Belt_Array.concat(t, [v]);
}

function prepend(t, v) {
  return Belt_Array.concat([v], t);
}

function mapi(prim0, prim1) {
  return prim0.map(Curry.__2(prim1));
}

function flatten(t) {
  return Belt_Array.concatMany(Belt_Array.map(t, (function (x) {
                    return x;
                  })));
}

function find(t, fn) {
  return Js_array.find(fn, t);
}

function findIndex(t, fn) {
  return Js_array.findIndex(fn, t);
}

function filter(prim0, prim1) {
  return prim0.filter(Curry.__1(prim1));
}

function reject(t, fn) {
  return t.filter(function (el) {
              return !fn(el);
            });
}

function sortBy(t, fn) {
  return Belt_SortArray.stableSortBy(t, (function (a, b) {
                var match = fn(a, b);
                if (match === "greater_than") {
                  return 1;
                } else if (match === "less_than") {
                  return -1;
                } else {
                  return 0;
                }
              }));
}

function joinWith(prim0, prim1) {
  return prim0.join(prim1);
}

function join(__x) {
  return __x.join("");
}

var $$String = {
  joinWith: joinWith,
  join: join
};

function eqBy(_xs, _ys, fn) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Belt_Array.get(xs, 0);
    var match$1 = Belt_Array.get(ys, 0);
    if (match === undefined) {
      return match$1 === undefined;
    }
    if (match$1 === undefined) {
      return false;
    }
    if (!fn(Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) {
      return false;
    }
    _ys = Belt_Array.sliceToEnd(ys, 1);
    _xs = Belt_Array.sliceToEnd(xs, 1);
    continue ;
  };
}

function takeWhile(t, fn) {
  var a = {
    contents: []
  };
  var maxLength = t.length - 1 | 0;
  var iter = function (_idx) {
    while(true) {
      var idx = _idx;
      if (idx >= maxLength) {
        return ;
      }
      var item = t[idx];
      if (!fn(item)) {
        return ;
      }
      a.contents = Belt_Array.concat(a.contents, [item]);
      _idx = idx + 1 | 0;
      continue ;
    };
  };
  iter(0);
  return a.contents;
}

function distinct(t, eq) {
  var maxIdx = t.length;
  var _acc = [];
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var acc = _acc;
    if (idx >= maxIdx) {
      return acc;
    }
    var y = t[idx];
    var acc$1 = Belt_Array.some(acc, (function(y){
        return function (x) {
          return eq(x, y);
        }
        }(y))) ? acc : Belt_Array.concat(acc, [y]);
    _idx = idx + 1 | 0;
    _acc = acc$1;
    continue ;
  };
}

function partition(t, fn) {
  var maxLength = t.length;
  var _a = [];
  var _b = [];
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var b = _b;
    var a = _a;
    if (idx >= maxLength) {
      return [
              a,
              b
            ];
    }
    var item = t[idx];
    var idx$1 = idx + 1 | 0;
    if (fn(item)) {
      _idx = idx$1;
      _a = Belt_Array.concat(a, [item]);
      continue ;
    }
    _idx = idx$1;
    _b = Belt_Array.concat(b, [item]);
    continue ;
  };
}

function replaceAt(t, idx, item) {
  return Belt_Array.mapWithIndex(t, (function (idx$p, el) {
                if (idx === idx$p) {
                  return item;
                } else {
                  return el;
                }
              }));
}

function indexOfBy(t, fn, value) {
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var value$p = Belt_Array.get(t, idx);
    if (value$p === undefined) {
      return ;
    }
    if (fn(value, Caml_option.valFromOption(value$p))) {
      return idx;
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function swapAt(t, i, j) {
  var match = Belt_Array.get(t, i);
  var match$1 = Belt_Array.get(t, j);
  if (match === undefined) {
    return t;
  }
  if (match$1 === undefined) {
    return t;
  }
  var b = Caml_option.valFromOption(match$1);
  var a = Caml_option.valFromOption(match);
  return Belt_Array.mapWithIndex(t, (function (k, x) {
                if (i === k) {
                  return b;
                } else if (j === k) {
                  return a;
                } else {
                  return x;
                }
              }));
}

function splitAt(t, i) {
  if (i < 0 || i > t.length) {
    return ;
  }
  var a = Belt_Array.slice(t, 0, i);
  var b = Belt_Array.sliceToEnd(t, i);
  return [
          a,
          b
        ];
}

function insertAt(t, idx, x) {
  var match = splitAt(t, idx);
  if (match !== undefined) {
    return Belt_Array.concat(match[0], Belt_Array.concat([x], match[1]));
  } else {
    return t;
  }
}

function flatMap(t, fn) {
  return Belt_Array.concatMany(Belt_Array.map(t, fn));
}

function removeAt(t, idx) {
  return Belt_Array.keepWithIndex(t, (function (param, i) {
                return i !== idx;
              }));
}

function drop(t, i) {
  var l = t.length;
  var start = i < 0 ? 0 : (
      l < i ? l : i
    );
  return Belt_Array.sliceToEnd(t, start);
}

function unsafePop(prim) {
  return Caml_option.undefined_to_opt(prim.pop());
}

function sum(xs) {
  return Belt_Array.reduce(xs, 0, (function (a, b) {
                return a + b | 0;
              }));
}

var Int = {
  sum: sum
};

function sum$1(xs) {
  return Belt_Array.reduce(xs, 0, (function (a, b) {
                return a + b;
              }));
}

var Float = {
  sum: sum$1
};

function clear(t) {
  t.length = 0;
}

var get = Belt_Array.get;

var getExn = Belt_Array.getExn;

var set = Belt_Array.set;

var setExn = Belt_Array.setExn;

var shuffleInPlace = Belt_Array.shuffleInPlace;

var shuffle = Belt_Array.shuffle;

var reverseInPlace = Belt_Array.reverseInPlace;

var reverse = Belt_Array.reverse;

var make = Belt_Array.make;

var range = Belt_Array.range;

var rangeBy = Belt_Array.rangeBy;

var makeByU = Belt_Array.makeByU;

var makeBy = Belt_Array.makeBy;

var makeByAndShuffleU = Belt_Array.makeByAndShuffleU;

var makeByAndShuffle = Belt_Array.makeByAndShuffle;

var zip = Belt_Array.zip;

var zipByU = Belt_Array.zipByU;

var zipBy = Belt_Array.zipBy;

var unzip = Belt_Array.unzip;

var concat = Belt_Array.concat;

var concatMany = Belt_Array.concatMany;

var slice = Belt_Array.slice;

var sliceToEnd = Belt_Array.sliceToEnd;

var fill = Belt_Array.fill;

var blit = Belt_Array.blit;

var blitUnsafe = Belt_Array.blitUnsafe;

var forEachU = Belt_Array.forEachU;

var forEach = Belt_Array.forEach;

var mapU = Belt_Array.mapU;

var map = Belt_Array.map;

var flatMapU = Belt_Array.flatMapU;

var getByU = Belt_Array.getByU;

var getBy = Belt_Array.getBy;

var getIndexByU = Belt_Array.getIndexByU;

var getIndexBy = Belt_Array.getIndexBy;

var keepU = Belt_Array.keepU;

var keep = Belt_Array.keep;

var keepWithIndexU = Belt_Array.keepWithIndexU;

var keepWithIndex = Belt_Array.keepWithIndex;

var keepMapU = Belt_Array.keepMapU;

var keepMap = Belt_Array.keepMap;

var forEachWithIndexU = Belt_Array.forEachWithIndexU;

var forEachWithIndex = Belt_Array.forEachWithIndex;

var mapWithIndexU = Belt_Array.mapWithIndexU;

var mapWithIndex = Belt_Array.mapWithIndex;

var partitionU = Belt_Array.partitionU;

var reduceU = Belt_Array.reduceU;

var reduce = Belt_Array.reduce;

var reduceReverseU = Belt_Array.reduceReverseU;

var reduceReverse = Belt_Array.reduceReverse;

var reduceReverse2U = Belt_Array.reduceReverse2U;

var reduceReverse2 = Belt_Array.reduceReverse2;

var reduceWithIndexU = Belt_Array.reduceWithIndexU;

var reduceWithIndex = Belt_Array.reduceWithIndex;

var joinWithU = Belt_Array.joinWithU;

var joinWith$1 = Belt_Array.joinWith;

var someU = Belt_Array.someU;

var some = Belt_Array.some;

var everyU = Belt_Array.everyU;

var every = Belt_Array.every;

var every2U = Belt_Array.every2U;

var every2 = Belt_Array.every2;

var some2U = Belt_Array.some2U;

var some2 = Belt_Array.some2;

var cmpU = Belt_Array.cmpU;

var cmp = Belt_Array.cmp;

var eqU = Belt_Array.eqU;

var eq = Belt_Array.eq;

var initU = Belt_Array.initU;

var init = Belt_Array.init;

var at = Belt_Array.get;

var sortByRaw = Belt_SortArray.stableSortBy;

export {
  get ,
  getExn ,
  set ,
  setExn ,
  shuffleInPlace ,
  shuffle ,
  reverseInPlace ,
  reverse ,
  make ,
  range ,
  rangeBy ,
  makeByU ,
  makeBy ,
  makeByAndShuffleU ,
  makeByAndShuffle ,
  zip ,
  zipByU ,
  zipBy ,
  unzip ,
  concat ,
  concatMany ,
  slice ,
  sliceToEnd ,
  fill ,
  blit ,
  blitUnsafe ,
  forEachU ,
  forEach ,
  mapU ,
  map ,
  flatMapU ,
  getByU ,
  getBy ,
  getIndexByU ,
  getIndexBy ,
  keepU ,
  keep ,
  keepWithIndexU ,
  keepWithIndex ,
  keepMapU ,
  keepMap ,
  forEachWithIndexU ,
  forEachWithIndex ,
  mapWithIndexU ,
  mapWithIndex ,
  partitionU ,
  reduceU ,
  reduce ,
  reduceReverseU ,
  reduceReverse ,
  reduceReverse2U ,
  reduceReverse2 ,
  reduceWithIndexU ,
  reduceWithIndex ,
  joinWithU ,
  joinWith$1 as joinWith,
  someU ,
  some ,
  everyU ,
  every ,
  every2U ,
  every2 ,
  some2U ,
  some2 ,
  cmpU ,
  cmp ,
  eqU ,
  eq ,
  initU ,
  init ,
  at ,
  includes ,
  head ,
  take ,
  last ,
  isEmpty ,
  isNotEmpty ,
  append ,
  prepend ,
  mapi ,
  flatten ,
  find ,
  findIndex ,
  filter ,
  reject ,
  sortBy ,
  sortByRaw ,
  $$String ,
  eqBy ,
  takeWhile ,
  distinct ,
  partition ,
  replaceAt ,
  indexOfBy ,
  swapAt ,
  splitAt ,
  insertAt ,
  flatMap ,
  removeAt ,
  drop ,
  unsafePop ,
  Int ,
  Float ,
  clear ,
}
/* No side effect */
